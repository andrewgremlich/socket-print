import { floor } from "mathjs";
import pkg from "pkg";
import { Vector3 } from "three";

import {
	getCircularSegments,
	getEPerRevolution,
	getLineWidthAdjustment,
	getSecondsPerLayer,
	getTestCylinderInnerDiameter,
} from "@/db/appSettingsDbActions";
import {
	getCupSize,
	getCupSizeHeight,
	getLayerHeight,
	getLockPosition,
	getNozzleSize,
} from "@/db/formValuesDbActions";
import {
	getActiveMaterialProfileCupTemp,
	getActiveMaterialProfileDensity,
	getActiveMaterialProfileGramsPerRevolution,
	getActiveMaterialProfileName,
	getActiveMaterialProfileNozzleTemp,
	getActiveMaterialProfileOutputFactor,
	getActiveMaterialProfileShrinkFactor,
} from "@/db/materialProfilesDbActions";
import type { CupSize, PrintObjectType } from "@/db/types";
import { NOZZLE_SIZE_OFFSET_FACTOR } from "@/utils/constants";
import {
	getCirclePoints,
	getTransitionLayer,
} from "@/utils/cupTransitionLayer";
import { getExtrusionCalculation } from "@/utils/getExtrusionCalculation";

export function flipVerticalAxis(currentAxis: "y" | "z"): "y" | "z" {
	return currentAxis === "y" ? "z" : "y";
}

function makeGCodePoint(
	point: Vector3,
	opts: {
		flipHeight: "y" | "z";
		verticalAxis: "y" | "z";
	},
): string {
	return `G1 X${-floor(point.x, 2)} Y${floor(point[opts.flipHeight], 2)} Z${floor(point[opts.verticalAxis], 2)}`;
}

async function getStartingX() {
	const testCylinderInnerDiameter = await getTestCylinderInnerDiameter();
	return testCylinderInnerDiameter / 2;
}

function generateGCodeHeader(params: {
	estimatedTime: string;
	materialProfile: {
		name: string;
		nozzleTemp: string | number;
		cupTemp: string | number;
		[key: string]: unknown;
	};
	formValues: {
		nozzleSize: number;
		cupSize: unknown;
		lockPosition: string;
		cupHeight: number;
		layerHeight: number;
	};
	appSettings: {
		secondsPerLayer: number;
		[key: string]: unknown;
	};
	startingHeight: number;
	transformedStartingX: number;
}): string[] {
	const {
		estimatedTime,
		materialProfile,
		formValues,
		appSettings,
		startingHeight,
		transformedStartingX,
	} = params;
	const lockPositionLabel = formValues.lockPosition === "left" ? "L" : "R";

	return [
		`;generated by ProvelPrint ${pkg.version} on ${new Date().toUTCString()}`,
		";TYPE:Custom",
		";metadata",
		`;estimated printing time (normal mode)=${estimatedTime}`,
		`;customInfo material="${materialProfile.name}"`,
		`;customInfo nozzleSize="${formValues.nozzleSize}mm"`,
		`;customInfo secondsPerLayer="${appSettings.secondsPerLayer}"`,
		`;customInfo cupSize="${(formValues.cupSize as CupSize).name} ${lockPositionLabel}"`,
		`;customInfo nozzleTemp="${materialProfile.nozzleTemp}C"`,
		`;customInfo cupTemp="${materialProfile.cupTemp}C"`,
		`;customInfo layerHeight="${formValues.layerHeight ?? "1"}mm"`,
		";# START GCODE SEQUENCE FOR CUP PRINT#;",
		"",
		"G21 ; Set units to millimeters",
		"G90 ; Use absolute positioning",
		"M83 ; use relative distances for extrusion",
		"T0 ; select tool 0",
		"",
		";## Set temperatures ##",
		"M106 P0 S0 H3 L0.15 X0.25 T20:40",
		`M568 P0 S${materialProfile.nozzleTemp} ; set temperature for barrel`,
		`M140 P1 S${materialProfile.cupTemp} ; set cup heater temperature`,
		"",
		";## Home ##",
		";G28",
		"",
		";## move to prime position / pickup cup heater start position ##",
		`G1 Y0 Z${formValues.cupHeight + 10} F6000 ; Z down to cup height + 10, Y moves back to cup center`,
		"G1 X-90 ; move in to register with cup heater for pickup",
		"M116 P0 S5 ; wait for nozzle temperature +/-5C",
		"M116 H2 S2 ; wait for cup temperature +/-2C",
		"",
		";## cup heater removal sequence ##",
		"M140 P1 S0 ; cup heater off",
		"set global.pelletFeedOn = true ; enable pellet feed",
		"G1 Z70 F6000 ; Z moves up to pick up cup heater",
		"G1 X130 F6000 ; X right to park cup heater",
		"G1 Z15 F6000 ; Z down to place cup heater on bed",
		"G1 X100 F6000 ; X left to disengage cup heater",
		`G1 Z${startingHeight} F6000 ; Z up to cup height + nozzleSize`,
		'M98 P"0:/sys/provel/prime.g" ; prime extruder',
		"",
		"G1 X50 Y0 F6000 ; Move to start of pre cup layer 1 extrusion",
		"G1 E15 ; extrude a bit to make up for any ooze",
		`G1 X${transformedStartingX} Y0 E10 F2250 ; Move to start of circle at the edge`,
		`G1 X${transformedStartingX} F2250 ; move back to cup`,
		"",
		";# End of start gcode sequence for cup print #",
		";## Spiral vase mode socket print to start immediately following this ##",
		"",
		";-------- print file --------",
	];
}

export async function generateGCode(
	pointGatherer: Vector3[][],
	feedratePerLevel: number[],
	verticalAxis: "y" | "z" = "y",
	options: {
		estimatedTime?: string;
		printObjectType?: PrintObjectType;
	} = {},
): Promise<string> {
	const { estimatedTime = "0m 0s" } = options;

	const [
		name,
		outputFactor,
		nozzleTempRaw,
		cupTempRaw,
		density,
		gramsPerRevolution,
		shrinkFactor,
		nozzleSize,
		cupSize,
		lockPosition,
		cupHeight,
		layerHeight,
		segments,
		secondsPerLayer,
		lineWidthAdjustment,
		ePerRevolution,
		startingX,
	] = await Promise.all([
		getActiveMaterialProfileName(),
		getActiveMaterialProfileOutputFactor(),
		getActiveMaterialProfileNozzleTemp(),
		getActiveMaterialProfileCupTemp(),
		getActiveMaterialProfileDensity(),
		getActiveMaterialProfileGramsPerRevolution(),
		getActiveMaterialProfileShrinkFactor(),
		getNozzleSize(),
		getCupSize(),
		getLockPosition(),
		getCupSizeHeight(),
		getLayerHeight(),
		getCircularSegments(),
		getSecondsPerLayer(),
		getLineWidthAdjustment(),
		getEPerRevolution(),
		getStartingX(),
	]);

	const materialProfile = {
		name,
		outputFactor,
		nozzleTemp: nozzleTempRaw ?? "195",
		cupTemp: cupTempRaw ?? "160",
		density,
		gramsPerRevolution,
	};
	const formValues = {
		nozzleSize,
		cupSize,
		lockPosition,
		cupHeight,
		layerHeight,
	};
	const appSettings = {
		segments,
		secondsPerLayer,
		lineWidthAdjustment,
		ePerRevolution,
	};
	const startingHeight = cupHeight + nozzleSize;
	const flipHeight = flipVerticalAxis(verticalAxis);
	const shrinkScale = floor(1 / (1 - shrinkFactor / 100), 4);
	const nozzleSizeOffset = nozzleSize / NOZZLE_SIZE_OFFSET_FACTOR;
	const transformedStartingX = startingX * shrinkScale + nozzleSizeOffset;

	const gcode = generateGCodeHeader({
		estimatedTime,
		materialProfile,
		formValues,
		appSettings,
		startingHeight,
		transformedStartingX,
	});

	let previousPoint = new Vector3(-transformedStartingX, startingHeight, 0);

	const circlePoints = await getCirclePoints(previousPoint, {
		segments,
		center: new Vector3(0, 0, 0),
		layerHeight,
		shrinkScale,
		nozzleSizeOffset,
	});
	const transitionLayer = await getTransitionLayer(circlePoints, {
		nozzleSize,
		outputFactor,
		offsetHeight: startingHeight,
		gramsPerRevolution,
		density,
		ePerRevolution,
	});

	gcode.push(
		";START TRANSITION LAYER",
		transitionLayer,
		";END TRANSITION LAYER",
	);

	const lastCirclePoint = circlePoints[circlePoints.length - 1].point;
	previousPoint = new Vector3(
		lastCirclePoint.x,
		lastCirclePoint.z,
		lastCirclePoint.y,
	).add(new Vector3(0, startingHeight, 0));

	const lineWidth = nozzleSize * lineWidthAdjustment;

	for (let i = 0; i < pointGatherer.length; i++) {
		const pointLevel = pointGatherer[i];
		gcode.push(";START NEW LEVEL");

		if (i === 0) gcode.push("M106 P2 S0 ; set fan speed");
		if (i === 1) gcode.push("M106 P2 S0.5 ; set fan speed");

		for (const point of pointLevel) {
			const adjustedPoint = point.clone().add(new Vector3(0, layerHeight, 0));
			const distance = previousPoint.distanceTo(adjustedPoint);
			const extrusion = getExtrusionCalculation({
				distance,
				layerHeight,
				lineWidth,
				gramsPerRevolution,
				density,
				ePerRevolution,
				outputFactor,
			});

			previousPoint = adjustedPoint;

			gcode.push(
				`${makeGCodePoint(adjustedPoint, { flipHeight, verticalAxis })} E${floor(extrusion, 2)} F${feedratePerLevel[i]}`,
			);
		}
	}

	gcode.push(
		";# END GCODE SEQUENCE FOR CUP PRINT #",
		"M107",
		"set global.pelletFeedOn = false",
		"G4 S1 ; pause for 1 second to stop extrudate",
		"if move.axes[2].machinePosition <490",
		"  G91",
		"  G1 Z3 F3000",
		"  G90",
		'M98 P"0:/sys/provel/purge.g"',
		"M106 S0 ; turn the blowers and fan off",
		"M140 S0 ; set bed temperature",
		'M98 P"0:/sys/provel/end.g"',
	);

	return gcode.join("\n");
}

export async function writeGCodeFile(
	gcodeString: string,
	fileName = "file.gcode",
) {
	if (window.isTauri) {
		const dialog = await import("@tauri-apps/plugin-dialog");
		const fs = await import("@tauri-apps/plugin-fs");
		const path = await dialog.save({
			title: "Save GCode file",
			defaultPath: fileName,
			filters: [{ name: "GCode", extensions: ["gcode"] }],
		});

		if (path) {
			await fs.writeFile(path, new TextEncoder().encode(gcodeString));
		}
	} else {
		const blob = new Blob([gcodeString], { type: "text/plain" });
		const link = document.createElement("a");
		link.href = URL.createObjectURL(blob);
		link.download = fileName;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	}
}
