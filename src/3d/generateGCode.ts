import { round, sqrt } from "mathjs";
import pkg from "pkg";

import {
	getActiveMaterialProfile,
	getCupSize,
	getCupSizeHeight,
	getLayerHeight,
	getLockPosition,
	getNozzleSize,
} from "@/db/keyValueSettings";
import {
	getActiveMaterialProfileNozzleTemp,
	getActiveMaterialProfileOutputFactor,
	getActiveMaterialProfileSecondsPerLayer,
} from "@/db/materialProfiles";

import type { RawPoint } from "./blendHardEdges";

export function flipVerticalAxis(currentAxis: "y" | "z"): "y" | "z" {
	return currentAxis === "y" ? "z" : "y";
}

export async function generateGCode(
	pointGatherer: RawPoint[][],
	feedratePerLevel: number[],
	verticalAxis: "y" | "z" = "y",
	options: {
		estimatedTime?: string;
	} = {},
): Promise<string> {
	const { estimatedTime = "0m 0s" } = options;
	const activeMaterialProfile = await getActiveMaterialProfile();
	const outputFactor = await getActiveMaterialProfileOutputFactor();
	const nozzleSize = await getNozzleSize();
	const cupSize = await getCupSize();
	const lockPosition = await getLockPosition();
	const secondsPerLayer = await getActiveMaterialProfileSecondsPerLayer();
	const layerHeight = await getLayerHeight();
	const nozzleTemp = (await getActiveMaterialProfileNozzleTemp()) ?? "195";
	const socketHeight = (await getCupSizeHeight()) + 5;
	const gcode = [
		`;generated by ProvelPrint ${pkg.version} on ${new Date().toUTCString()}`,
		";TYPE:Custom",
		";metadata",
		`;estimated printing time (normal mode)="${estimatedTime}"`,
		`;customInfo material="${activeMaterialProfile}"`,
		`;customInfo nozzleSize="${nozzleSize}mm"`,
		`;customInfo secondsPerLayer="${secondsPerLayer}"`,
		`;customInfo cupSize="${cupSize} ${lockPosition === "left" ? "L" : "R"}"`,
		`;customInfo nozzleTemp="${nozzleTemp}C"`,
		`;customInfo layerHeight="${layerHeight ?? "1"}mm"`,
		";# START GCODE SEQUENCE FOR CUP PRINT#;",

		"G21 ; Set units to millimeters",
		"G90 ; Use absolute positioning",
		"M83 ; use relative distances for extrusion",

		";## Set temperatures ##",
		"M568 P0 S200 ; set temperature for barrel to 200;",
		"M140 P1 S160  ; set cup heater temperature to 160 and continue",

		";## Home ##",
		";G28",

		";## move to prime position/ pickup cup heater start position ##",
		"G1 Y0 Z48 F6000 ;Z down to cup height + 10 , Y moves back to cup center",
		"G1 X-90 ; only once at correct Z height move in to register with cup heater for pickup",
		"M116 S10 ; wait for temperatures to be reached +/-10C (including cup heater)",

		";##cup heater removal sequence##",
		"M140 P1 S0 ;cup heater off",
		"set global.pelletFeedOn = true  ; enable pellet feed",
		"G1 Z70 F6000; Z moves up to pick up cup heater",
		"G1 X120 F6000; X right to park cup heater",
		"G1 Z15 F6000; Z down to place cup heater on bed",
		"G1 X95 F6000; X left to disengage cup heater",
		`G1 Z${socketHeight} F6000; Z up to CH + 5 for groove fill`,
		'M98 P"0:/sys/provel/prime.g"   ;prime extruder',
		// "G4 S2 ; pause for 2 seconds for prime to finish",

		// Groove fill was removed because the cups do not require it anymore.
		";##Groove fill",
		"G1 X50 Y0 F6000 ; Move to start of pre groove fill extrusion",
		// "G1 E15 E300 ; extrude a bit to make up for any ooze",
		"G1 E15 ; extrude a bit to make up for any ooze",
		"G1 X36 Y0 E10 F2250 ; Move to start of circle at the edge, continue slight extrusion",
		// "G1 E20 E300 ;extruder a bit to prevent a small gap at the start/end.",
		" ;Extrude in a circle A",
		"G1 X38.5 F2250 	     		; 7.16.25 move back to cup",
		"G3 X38.5 Y0 I-38.5 J0 E255 F1200 ; Counter-Clockwise circle around (0,0) with radius 39mm (1030 tested in practice complete groove fill).",

		";#End of start gcode sequence for cup print#",
		";##Spiral vase mode socket print to start immediately following this.",

		";--------print file in here--------",
	];

	let previousPoint: RawPoint = { x: -38.5, y: socketHeight, z: 0.0 }; // hardcoded start point... see from gcode ALSO this must be Three.Js orientation context

	gcode.push(
		`G1 X${-round(previousPoint.x, 2)} Y${round(previousPoint.z, 2)} Z${round(previousPoint.y, 2)} F2250`,
	);

	for (let i = 0; i < pointGatherer.length; i++) {
		const pointLevel = pointGatherer[i];

		gcode.push(";START NEW LEVEL");

		if (i === 0) {
			gcode.push("M106 P2 S0 ; set fan speed");
		}

		if (i === 1) {
			gcode.push("M106 P2 S0.5 ; set fan speed");
		}

		// if (i === 2) {
		// 	gcode.push("M106 P2 S1 ; set fan speed");
		// }

		for (let j = 0; j < pointLevel.length; j++) {
			let extrusion = 0;

			const point = pointLevel[j];
			const dx = round(point.x, 2) - round(previousPoint.x, 2);
			const dy = round(point.y, 2) - round(previousPoint.y, 2);
			const dz = round(point.z, 2) - round(previousPoint.z, 2);
			const distance = sqrt(dx * dx + dy * dy + dz * dz) as number;

			const lineWidth = nozzleSize * (outputFactor / 100);
			const extrusionVolume = distance * layerHeight * lineWidth;

			extrusion = extrusionVolume;

			if (i === 0 && j === 0) {
				console.log({
					point: {
						x: round(point.x, 2),
						y: round(point.y, 2),
						z: round(point.z, 2),
					},
					previousPoint,
				});
				console.log(`Extrusion for point ${j}: ${extrusion}`, {
					nozzleSize,
					outputFactor,
					layerHeight,
					distance,
					lineWidth,
				});
			}

			// if (i === 0) {
			// 	extrusion = extrusion * ((j + 1) / pointLevel.length);
			// }

			previousPoint = point;
			const flipHeight = flipVerticalAxis(verticalAxis);
			gcode.push(
				`G1 X${-round(point.x, 2)} Y${round(point[flipHeight], 2)} Z${round(point[verticalAxis], 2)} E${round(extrusion, 2)} F${feedratePerLevel[i]}`,
			);
		}
	}

	gcode.push(
		";# END GCODE SEQUENCE FOR CUP PRINT#;",
		// "G1 Z3 F6000 ; move up 3mm before purge",
		"M107",
		"set global.pelletFeedOn = false",
		"G4 S1 ; pause for 1 second to stop extrudate",
		'M98 P"0:/sys/provel/purge.g"',
		"M106 S0; turn the blowers and fan off",
		"M140 S0 ; set bed temperature",
		'M98 P"0:/sys/provel/end.g"',
	);

	return gcode.join("\n");
}

/**
 * Writes the provided G-code string to a file, handling both Tauri and browser environments.
 *
 * - In a Tauri environment, opens a save dialog for the user to choose the file location,
 *   then writes the G-code string to the selected file using the Tauri filesystem API.
 * - In a browser environment, triggers a download of the G-code string as a `.gcode` file.
 *
 * @param gcodeString - The G-code content to be written to the file.
 * @param fileName - The default file name to use for saving the G-code file (defaults to "file.gcode").
 * @returns A promise that resolves when the file has been written or the download has been triggered.
 */
export async function writeGCodeFile(
	gcodeString: string,
	fileName = "file.gcode",
) {
	if (window.isTauri) {
		const dialog = await import("@tauri-apps/plugin-dialog");
		const fs = await import("@tauri-apps/plugin-fs");
		const path = await dialog.save({
			title: "Save GCode file",
			defaultPath: fileName,
			filters: [
				{
					name: "GCode",
					extensions: ["gcode"],
				},
			],
		});

		await fs.writeFile(`${path}`, new TextEncoder().encode(gcodeString));
	} else {
		const blob = new Blob([gcodeString], { type: "text/plain" });
		const link = document.createElement("a");

		link.href = URL.createObjectURL(blob);
		link.download = fileName;

		document.body.appendChild(link);

		link.click();

		document.body.removeChild(link);
	}
}
