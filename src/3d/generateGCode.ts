import { floor } from "mathjs";
import pkg from "pkg";
import { Vector3 } from "three";

import {
	getCircularSegments,
	getEPerRevolution,
	getLineWidthAdjustment,
	getSecondsPerLayer,
} from "@/db/appSettingsDbActions";
import {
	getCupSize,
	getCupSizeHeight,
	getLayerHeight,
	getLockPosition,
	getNozzleSize,
} from "@/db/formValuesDbActions";
import {
	getActiveMaterialProfileCupTemp,
	getActiveMaterialProfileDensity,
	getActiveMaterialProfileGramsPerRevolution,
	getActiveMaterialProfileName,
	getActiveMaterialProfileNozzleTemp,
	getActiveMaterialProfileOutputFactor,
} from "@/db/materialProfilesDbActions";
import {
	getCirclePoints,
	getTransitionLayer,
} from "@/utils/cupTransitionLayer";
import { getExtrusionCalculation } from "@/utils/getExtrusionCalculation";

export function flipVerticalAxis(currentAxis: "y" | "z"): "y" | "z" {
	return currentAxis === "y" ? "z" : "y";
}

function makeGCodePoint(
	point: Vector3,
	opts: {
		flipHeight: "y" | "z";
		verticalAxis: "y" | "z";
	},
): string {
	return `G1 X${-floor(point.x, 2)} Y${floor(point[opts.flipHeight], 2)} Z${floor(point[opts.verticalAxis], 2)}`;
}

export async function generateGCode(
	pointGatherer: Vector3[][],
	feedratePerLevel: number[],
	verticalAxis: "y" | "z" = "y",
	options: {
		estimatedTime?: string;
	} = {},
): Promise<string> {
	const { estimatedTime = "0m 0s" } = options;
	const [
		activeMaterialProfileName,
		outputFactor,
		nozzleSize,
		cupSize,
		segments,
		lockPosition,
		secondsPerLayer,
		lineWidthAdjustment,
		cupHeight,
		layerHeight,
		nozzleTempRaw,
		cupTempRaw,
		density,
		gramsPerRevolution,
		ePerRevolution,
	] = await Promise.all([
		getActiveMaterialProfileName(),
		getActiveMaterialProfileOutputFactor(),
		getNozzleSize(),
		getCupSize(),
		getCircularSegments(),
		getLockPosition(),
		getSecondsPerLayer(),
		getLineWidthAdjustment(),
		getCupSizeHeight(),
		getLayerHeight(),
		getActiveMaterialProfileNozzleTemp(),
		getActiveMaterialProfileCupTemp(),
		getActiveMaterialProfileDensity(),
		getActiveMaterialProfileGramsPerRevolution(),
		getEPerRevolution(),
	]);
	const nozzleTemp = nozzleTempRaw ?? "195";
	const cupTemp = cupTempRaw ?? "160";
	const startingHeight = cupHeight + nozzleSize;
	const flipHeight = flipVerticalAxis(verticalAxis);

	const gcode = [
		`;generated by ProvelPrint ${pkg.version} on ${new Date().toUTCString()}`,
		";TYPE:Custom",
		";metadata",
		`;estimated printing time (normal mode)=${estimatedTime}`,
		`;customInfo material="${activeMaterialProfileName}"`,
		`;customInfo nozzleSize="${nozzleSize}mm"`,
		`;customInfo secondsPerLayer="${secondsPerLayer}"`,
		`;customInfo cupSize="${cupSize} ${lockPosition === "left" ? "L" : "R"}"`,
		`;customInfo nozzleTemp="${nozzleTemp}C"`,
		`;customInfo cupTemp="${cupTemp}C"`,
		`;customInfo layerHeight="${layerHeight ?? "1"}mm"`,
		";# START GCODE SEQUENCE FOR CUP PRINT#;",

		"G21 ; Set units to millimeters",
		"G90 ; Use absolute positioning",
		"M83 ; use relative distances for extrusion",
		"T0 ;select tool 0",

		";## Set temperatures ##",
		"M106 P0 S0 H3 L0.15 X0.25 T20:40",
		"M568 P0 S200 ; set temperature for barrel to 200;",
		`M140 P1 S${cupTemp}  ; set cup heater temperature to ${cupTemp} and continue`,

		";## Home ##",
		";G28",

		";## move to prime position/ pickup cup heater start position ##",
		`G1 Y0 Z${cupHeight + 10} F6000 ;Z down to cup height + 10 , Y moves back to cup center`,
		"G1 X-90 ; only once at correct Z height move in to register with cup heater for pickup",
		"M116 P0 S5 ; wait for nozzle temperature to be reached +/-5C",
		"M116 H2 S2 ; wait for cup temperature to be reached +/-2C",

		";##cup heater removal sequence##",
		"M140 P1 S0 ;cup heater off",
		"set global.pelletFeedOn = true  ; enable pellet feed",
		"G1 Z70 F6000; Z moves up to pick up cup heater",
		"G1 X130 F6000; X right to park cup heater",
		"G1 Z15 F6000; Z down to place cup heater on bed",
		"G1 X100 F6000; X left to disengage cup heater",
		`G1 Z${startingHeight} F6000; Z up to cup height + nozzleSize for cup layer`,
		'M98 P"0:/sys/provel/prime.g"   ;prime extruder',

		// ";##Cup Layer 1",
		"G1 X50 Y0 F6000 ; Move to start of pre cup layer 1 extrusion",
		"G1 E15 ; extrude a bit to make up for any ooze",
		"G1 X36 Y0 E10 F2250 ; Move to start of circle at the edge, continue slight extrusion",
		// ";Extrude in a circle A",
		"G1 X38.5 F2250 	     		; 7.16.25 move back to cup",
		// "G3 X38.5 Y0 I-38.5 J0 E255 F1200 ; Counter-Clockwise circle around (0,0) with radius 39mm (1030 tested in practice complete cup layer 1).",

		";#End of start gcode sequence for cup print#",
		";##Spiral vase mode socket print to start immediately following this.",

		";--------print file in here--------",
	];

	let previousPoint: Vector3 = new Vector3(-38.5, startingHeight, 0); // hardcoded start point... see from gcode ALSO this must be Three.Js orientation context

	const circlePoints = await getCirclePoints(previousPoint, {
		segments,
		center: new Vector3(0, 0, 0),
		layerHeight,
	});
	const transitionLayer = await getTransitionLayer(circlePoints, {
		nozzleSize,
		outputFactor,
		offsetHeight: startingHeight,
		gramsPerRevolution,
		density,
		ePerRevolution,
	});

	gcode.push(";START TRANSITION LAYER");
	gcode.push(transitionLayer);
	gcode.push(";END TRANSITION LAYER");

	const tempPoint = circlePoints[circlePoints.length - 1].point;
	previousPoint = new Vector3(tempPoint.x, tempPoint.z, tempPoint.y).add(
		new Vector3(0, startingHeight, 0),
	);

	for (let i = 0; i < pointGatherer.length; i++) {
		const pointLevel = pointGatherer[i];

		gcode.push(";START NEW LEVEL");

		if (i === 0) {
			gcode.push("M106 P2 S0 ; set fan speed");
		}

		if (i === 1) {
			gcode.push("M106 P2 S0.5 ; set fan speed");
		}

		for (let j = 0; j < pointLevel.length; j++) {
			const point = pointLevel[j].clone().add(new Vector3(0, layerHeight, 0));
			const distance = previousPoint.distanceTo(point);
			const lineWidth = nozzleSize * lineWidthAdjustment;
			const extrusion = getExtrusionCalculation({
				distance,
				layerHeight,
				lineWidth,
				gramsPerRevolution,
				density,
				ePerRevolution,
				outputFactor,
			});

			previousPoint = point;

			gcode.push(
				`${makeGCodePoint(point, { flipHeight, verticalAxis })} E${floor(extrusion, 2)} F${feedratePerLevel[i]}`,
			);
		}
	}

	gcode.push(
		";# END GCODE SEQUENCE FOR CUP PRINT#;",
		"M107",
		"set global.pelletFeedOn = false",
		"G4 S1 ; pause for 1 second to stop extrudate",
		";raise",
		"if move.axes[2].machinePosition <490",
		"  G91",
		"  G1 Z3 F3000",
		"  G90",
		'M98 P"0:/sys/provel/purge.g"',
		"M106 S0; turn the blowers and fan off",
		"M140 S0 ; set bed temperature",
		'M98 P"0:/sys/provel/end.g"',
	);

	return gcode.join("\n");
}

/**
 * Writes the provided G-code string to a file, handling both Tauri and browser environments.
 *
 * - In a Tauri environment, opens a save dialog for the user to choose the file location,
 *   then writes the G-code string to the selected file using the Tauri filesystem API.
 * - In a browser environment, triggers a download of the G-code string as a `.gcode` file.
 *
 * @param gcodeString - The G-code content to be written to the file.
 * @param fileName - The default file name to use for saving the G-code file (defaults to "file.gcode").
 * @returns A promise that resolves when the file has been written or the download has been triggered.
 */
export async function writeGCodeFile(
	gcodeString: string,
	fileName = "file.gcode",
) {
	if (window.isTauri) {
		const dialog = await import("@tauri-apps/plugin-dialog");
		const fs = await import("@tauri-apps/plugin-fs");
		const path = await dialog.save({
			title: "Save GCode file",
			defaultPath: fileName,
			filters: [
				{
					name: "GCode",
					extensions: ["gcode"],
				},
			],
		});

		await fs.writeFile(`${path}`, new TextEncoder().encode(gcodeString));
	} else {
		const blob = new Blob([gcodeString], { type: "text/plain" });
		const link = document.createElement("a");

		link.href = URL.createObjectURL(blob);
		link.download = fileName;

		document.body.appendChild(link);

		link.click();

		document.body.removeChild(link);
	}
}
